//! SAS program generation.

use std::collections::{BTreeMap, BTreeSet};
use std::path::{Path, PathBuf};

use anyhow::{Context, Result, anyhow};
use chrono::{SecondsFormat, Utc};

use sdtm_transform::frame::DomainFrame;
use sdtm_model::{Domain, MappingConfig, MappingSuggestion, Variable, VariableType};

use crate::common::{dataset_name, domain_map, is_required, should_upcase, variable_length};

/// Options for SAS program generation.
#[derive(Debug, Clone, Default)]
pub struct SasProgramOptions {
    pub input_dataset: Option<String>,
    pub output_dataset: Option<String>,
}

/// Write SAS program outputs for all domains.
pub fn write_sas_outputs(
    output_dir: &Path,
    domains: &[Domain],
    frames: &[DomainFrame],
    mappings: &BTreeMap<String, MappingConfig>,
    options: &SasProgramOptions,
) -> Result<Vec<PathBuf>> {
    let domain_lookup = domain_map(domains);
    let mut frames_sorted: Vec<&DomainFrame> = frames.iter().collect();
    frames_sorted.sort_by(|a, b| a.domain_code.cmp(&b.domain_code));

    let sas_dir = output_dir.join("sas");
    std::fs::create_dir_all(&sas_dir).with_context(|| format!("create {}", sas_dir.display()))?;

    let mut outputs = Vec::new();
    for frame in frames_sorted {
        let code = frame.domain_code.to_uppercase();
        let domain = domain_lookup
            .get(&code)
            .ok_or_else(|| anyhow!("missing domain definition for {code}"))?;
        let mapping = mappings
            .get(&code)
            .ok_or_else(|| anyhow!("missing mapping config for {code}"))?;
        // Use frame's dataset name (from metadata) for split domains
        let output_dataset_name = frame.dataset_name();
        let disk_name = output_dataset_name.to_lowercase();
        let path = sas_dir.join(format!("{disk_name}.sas"));
        let sas_options = SasProgramOptions {
            output_dataset: Some(format!("sdtm.{}", disk_name)),
            ..options.clone()
        };
        let program = generate_sas_program(domain, frame, mapping, &sas_options)?;
        std::fs::write(&path, program).with_context(|| format!("write {}", path.display()))?;
        outputs.push(path);
    }
    Ok(outputs)
}

/// Generate a SAS program for a single domain.
pub fn generate_sas_program(
    domain: &Domain,
    frame: &DomainFrame,
    mapping: &MappingConfig,
    options: &SasProgramOptions,
) -> Result<String> {
    let input_dataset = options
        .input_dataset
        .clone()
        .unwrap_or_else(|| format!("work.{}", domain.code.to_lowercase()));
    let output_dataset = options
        .output_dataset
        .clone()
        .unwrap_or_else(|| format!("sdtm.{}", dataset_name(domain).to_lowercase()));
    let timestamp = Utc::now().to_rfc3339_opts(SecondsFormat::Secs, true);

    let mut lines = Vec::new();
    lines.push("/* Generated by CDISC Transpiler */".to_string());
    lines.push(format!("/* Domain: {} */", domain.code));
    lines.push(format!("/* Generated: {} */", timestamp));
    lines.push(String::new());
    lines.push(format!("DATA {output_dataset};"));
    lines.push(format!("    SET {input_dataset};"));
    lines.push("    length".to_string());
    for variable in &domain.variables {
        let length = variable_length(variable, &frame.data)?;
        let suffix = if variable.data_type == VariableType::Char {
            format!("${length}")
        } else {
            format!("{length}")
        };
        lines.push(format!("        {} {}", variable.name, suffix));
    }
    lines.push("    ;".to_string());
    lines.push(String::new());
    lines.push("    /* Column mappings */".to_string());
    let assignment_map = build_assignment_map(domain, mapping);
    for assignment in assignment_map {
        for line in assignment.lines() {
            lines.push(format!("    {line}"));
        }
    }
    lines.push(String::new());
    lines.push("    /* Defaulted required fields */".to_string());
    for default_line in default_assignments(domain, mapping) {
        lines.push(format!("    {default_line}"));
    }
    if let Some(study_col) = domain.column_name("STUDYID") {
        lines.push(format!("    {study_col} = \"{}\";", mapping.study_id));
    }
    if let Some(domain_col) = domain.column_name("DOMAIN") {
        lines.push(format!("    {domain_col} = \"{}\";", domain.code));
    }
    lines.push(String::new());
    lines.push(format!("    KEEP {};", keep_clause(domain)));
    lines.push("RUN;".to_string());
    Ok(lines.join("\n"))
}

/// Build assignment statements from mapping.
fn build_assignment_map(domain: &Domain, mapping: &MappingConfig) -> Vec<String> {
    let mut variable_lookup = BTreeMap::new();
    for variable in &domain.variables {
        variable_lookup.insert(variable.name.to_uppercase(), variable);
    }
    let mut assignments = Vec::new();
    for item in &mapping.mappings {
        let variable = variable_lookup
            .get(&item.target_variable.to_uppercase())
            .copied();
        assignments.push(render_assignment(item, variable));
    }
    assignments
}

/// Render a single assignment statement.
fn render_assignment(mapping: &MappingSuggestion, variable: Option<&Variable>) -> String {
    let mut expr = mapping
        .transformation
        .clone()
        .unwrap_or_else(|| mapping.source_column.clone());
    if let Some(var) = variable
        && var.data_type == VariableType::Char
    {
        expr = format!("strip(coalescec({}, ''))", expr);
        if should_upcase(var) {
            expr = format!("upcase({expr})");
        }
    }
    format!("{} = {};", mapping.target_variable, expr)
}

/// Generate default assignments for required but unmapped variables.
fn default_assignments(domain: &Domain, mapping: &MappingConfig) -> Vec<String> {
    let mut mapped: BTreeSet<String> = mapping
        .mappings
        .iter()
        .map(|item| item.target_variable.to_uppercase())
        .collect();
    let mut defaults = Vec::new();
    for variable in &domain.variables {
        if !is_required(variable) {
            continue;
        }
        if mapped.contains(&variable.name.to_uppercase()) {
            continue;
        }
        defaults.push(default_assignment(variable));
        mapped.insert(variable.name.to_uppercase());
    }
    defaults
}

/// Generate default assignment for a variable.
fn default_assignment(variable: &Variable) -> String {
    match variable.data_type {
        VariableType::Num => format!("{} = .;", variable.name),
        // Treat Char and future types as string
        VariableType::Char | _ => format!("{} = '';", variable.name),
    }
}

/// Generate KEEP clause for domain variables.
fn keep_clause(domain: &Domain) -> String {
    domain
        .variables
        .iter()
        .map(|var| var.name.as_str())
        .collect::<Vec<_>>()
        .join(" ")
}

#[cfg(test)]
mod tests {
    use super::*;

    fn test_variable(name: &str, data_type: VariableType) -> Variable {
        Variable {
            name: name.to_string(),
            label: Some(format!("{} Label", name)),
            data_type,
            length: None,
            role: None,
            core: None,
            codelist_code: None,
            order: None,
        }
    }

    fn test_domain() -> Domain {
        Domain {
            code: "AE".to_string(),
            description: Some("Adverse Events".to_string()),
            class_name: Some("Events".to_string()),
            dataset_class: None,
            label: Some("Adverse Events".to_string()),
            structure: Some("One record per event".to_string()),
            dataset_name: None,
            variables: vec![
                {
                    let mut v = test_variable("STUDYID", VariableType::Char);
                    v.role = Some("Identifier".to_string());
                    v.core = Some("Req".to_string());
                    v
                },
                {
                    let mut v = test_variable("USUBJID", VariableType::Char);
                    v.role = Some("Identifier".to_string());
                    v.core = Some("Req".to_string());
                    v
                },
                {
                    let mut v = test_variable("AETERM", VariableType::Char);
                    v.role = Some("Topic".to_string());
                    v.core = Some("Req".to_string());
                    v
                },
                {
                    let mut v = test_variable("AESTDTC", VariableType::Char);
                    v.role = Some("Timing".to_string());
                    v
                },
            ],
        }
    }

    #[test]
    fn test_keep_clause() {
        let domain = test_domain();
        let clause = keep_clause(&domain);

        assert!(clause.contains("STUDYID"));
        assert!(clause.contains("USUBJID"));
        assert!(clause.contains("AETERM"));
        assert!(clause.contains("AESTDTC"));
    }

    #[test]
    fn test_default_assignment_char() {
        let variable = test_variable("AETERM", VariableType::Char);
        assert_eq!(default_assignment(&variable), "AETERM = '';");
    }

    #[test]
    fn test_default_assignment_num() {
        let variable = test_variable("AESEQ", VariableType::Num);
        assert_eq!(default_assignment(&variable), "AESEQ = .;");
    }
}
