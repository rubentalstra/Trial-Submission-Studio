"""SAS writer adapter.

This module contains the concrete implementation for generating SAS programs
and writing them to disk.

It intentionally consolidates what used to live in multiple SAS-related
modules to keep the I/O layer easier to navigate.
"""

from __future__ import annotations

from datetime import UTC, datetime
from functools import lru_cache
from pathlib import Path
import re
from typing import TYPE_CHECKING

from jinja2 import Environment, StrictUndefined

from cdisc_transpiler.infrastructure.repositories.ct_repository import CTRepository
from cdisc_transpiler.infrastructure.sdtm_spec.registry import get_domain

if TYPE_CHECKING:
    from ...domain.entities.mapping import MappingConfig
    from cdisc_transpiler.domain.entities.mapping import ColumnMapping
    from cdisc_transpiler.domain.entities.sdtm_domain import SDTMDomain, SDTMVariable


SAS_PROGRAM_TEMPLATE = """/* Generated by CDISC Transpiler */
/* Domain: {{ domain.code }} */
/* Generated: {{ timestamp }} */

DATA {{ output_dataset }};
    SET {{ input_dataset }};
    length
    {%- for variable in domain.variables %}
        {{ variable.name }} ${{ variable.length }}
    {%- endfor %}
    ;

    /* Column mappings */
    {%- for assignment in assignments %}
    {{ assignment }}
    {%- endfor %}

    /* Defaulted required fields */
    {%- for default_line in default_assignments %}
    {{ default_line }}
    {%- endfor %}

    STUDYID = "{{ study_id }}";
    DOMAIN = "{{ domain.code }}";

    KEEP {{ keep_clause }};
RUN;
"""

DEFAULT_STUDY_ID = "STUDY"
SAS_FILE_ENCODING = "utf-8"


@lru_cache(maxsize=1)
def _ct_repository() -> CTRepository:
    return CTRepository()


_WHITESPACE_RE = re.compile(r"\s+")


def _normalize_token(value: str) -> str:
    upper = (value or "").strip().upper()
    upper = upper.replace("_", " ").replace("-", " ")
    upper = _WHITESPACE_RE.sub(" ", upper)
    return upper


def _token_variants(value: str) -> set[str]:
    raw = (value or "").strip()
    if not raw:
        return set()
    base = raw.upper().strip()
    variants = {base, _normalize_token(base)}
    variants.add(_normalize_token(base.replace(",", " ")))
    variants.add(_normalize_token(base.replace("/", " ")))
    return {v for v in variants if v}


def _parse_submission_values(raw: str | None) -> set[str]:
    if not raw:
        return set()
    text = str(raw).strip()
    if not text:
        return set()

    tokens: list[str] = []
    for sep in [";", ","]:
        if sep in text:
            tokens = [t.strip() for t in text.split(sep)]
            break
    if not tokens:
        tokens = [text]

    cleaned = {t.strip().strip('"').upper() for t in tokens if t.strip()}
    return {c for c in cleaned if c}


def _get_ct_value_map(
    variable_name: str, variable: "SDTMVariable | None"
) -> dict[str, set[str]] | None:
    ct = None
    if variable is not None and variable.codelist_code:
        ct = _ct_repository().get_by_code(variable.codelist_code)
    if ct is None:
        ct = _ct_repository().get_by_name(variable_name)
    if ct is None:
        return None

    value_map: dict[str, set[str]] = {}

    for canonical in ct.submission_values:
        value_map[canonical] = set(_token_variants(canonical)) | {canonical}

    if ct.synonyms:
        for syn_key, canonical in ct.synonyms.items():
            if not canonical:
                continue
            bucket = value_map.setdefault(canonical, set())
            bucket.update(_token_variants(syn_key))
            bucket.update(_token_variants(canonical))

    return value_map


def _get_spec_value_map(variable: "SDTMVariable | None") -> dict[str, set[str]] | None:
    if variable is None:
        return None
    canonicals = _parse_submission_values(variable.codelist_submission_values)
    if not canonicals:
        return None
    return {c: set(_token_variants(c)) | {c} for c in canonicals}


def _render_value_map(mapping: "ColumnMapping", value_map: dict[str, set[str]]) -> str:
    source = mapping.source_column
    target = mapping.target_variable

    lines = [
        f"{target} = strip(coalescec({source}, ''));",
        f"{target} = upcase({target});",
        f"select ({target});",
    ]

    for canonical, synonyms in value_map.items():
        formatted = ", ".join(f"'{s}'" for s in sorted(synonyms))
        lines.append(f"    when ({formatted}) {target} = '{canonical}';")

    lines.append("    otherwise; /* keep as-is */")
    lines.append("end;")
    return "\n".join(lines)


def render_assignment(mapping: "ColumnMapping", variable: "SDTMVariable | None") -> str:
    target_name = mapping.target_variable.upper()

    if mapping.transformation:
        expr = mapping.transformation
        return f"{mapping.target_variable} = {expr};"

    ct_value_map = _get_ct_value_map(target_name, variable)
    if ct_value_map:
        return _render_value_map(mapping, ct_value_map)

    spec_value_map = _get_spec_value_map(variable)
    if spec_value_map:
        return _render_value_map(mapping, spec_value_map)

    expr = mapping.source_column
    is_character = False
    if variable:
        is_character = variable.type.lower() == "char"

    if is_character:
        expr = f"coalescec({expr}, '')"
        expr = f"strip({expr})"
        if variable is not None:
            role = (variable.role or "").strip().lower()
            has_explicit_values = bool(variable.codelist_code) or bool(
                _parse_submission_values(variable.codelist_submission_values)
            )
            if role == "identifier" or has_explicit_values:
                expr = f"upcase({expr})"

    return f"{mapping.target_variable} = {expr};"


def get_default_value_assignment(variable: "SDTMVariable") -> str:
    if variable.type.lower() == "num":
        return f"{variable.name} = .;"
    return f"{variable.name} = '';"


def get_default_assignments(domain: "SDTMDomain", config: "MappingConfig") -> list[str]:
    defaults: list[str] = []
    mapped_variables = config.target_variables

    for variable in domain.variables:
        if (
            variable.name in mapped_variables
            and (variable.core or "").strip().lower() == "req"
        ):
            continue

        if (variable.core or "").strip().lower() != "req":
            continue

        defaults.append(get_default_value_assignment(variable))

    return defaults


def get_assignment_for_mapping(mapping: "ColumnMapping", domain: "SDTMDomain") -> str:
    variable_lookup = {var.name: var for var in domain.variables}
    variable = variable_lookup.get(mapping.target_variable)
    return render_assignment(mapping, variable)


def get_keep_clause(domain: "SDTMDomain") -> str:
    return " ".join(domain.variable_names())


class SASProgramGenerator:
    def __init__(self) -> None:
        self._env = Environment(
            trim_blocks=True,
            lstrip_blocks=True,
            undefined=StrictUndefined,
        )
        self._template = self._env.from_string(SAS_PROGRAM_TEMPLATE)

    def generate(
        self,
        domain_code: str,
        config: "MappingConfig",
        input_dataset: str,
        output_dataset: str,
    ) -> str:
        domain = get_domain(domain_code)

        assignments = [
            get_assignment_for_mapping(mapping, domain) for mapping in config.mappings
        ]
        default_assignments = get_default_assignments(domain, config)
        keep_clause = get_keep_clause(domain)
        study_id = config.study_id or DEFAULT_STUDY_ID

        return self._template.render(
            domain=domain,
            timestamp=datetime.now(UTC).isoformat(timespec="seconds"),
            assignments=assignments,
            default_assignments=default_assignments,
            keep_clause=keep_clause,
            input_dataset=input_dataset,
            output_dataset=output_dataset,
            study_id=study_id,
        )


def generate_sas_program(
    domain_code: str,
    config: "MappingConfig",
    input_dataset: str,
    output_dataset: str,
) -> str:
    generator = SASProgramGenerator()
    return generator.generate(domain_code, config, input_dataset, output_dataset)


def write_sas_file(code: str, path: str | Path) -> None:
    file_path = Path(path)
    file_path.parent.mkdir(parents=True, exist_ok=True)

    with file_path.open("w", encoding=SAS_FILE_ENCODING) as handle:
        handle.write(code)


class SASWriterError(RuntimeError):
    """Raised when SAS program generation or writing fails."""


class SASWriter:
    """Adapter for generating and writing SAS programs.

    This class implements the SASWriterPort protocol.

    Example:
        >>> writer = SASWriter()
        >>> writer.write("DM", config, Path("output/dm.sas"), "work.dm", "sdtm.dm")
    """

    def write(
        self,
        domain_code: str,
        config: MappingConfig,
        output_path: Path,
        input_dataset: str | None = None,
        output_dataset: str | None = None,
    ) -> None:
        """Generate and write a SAS program.

        Args:
            domain_code: SDTM domain code (e.g., "DM", "AE")
            config: Mapping configuration with column metadata
            output_path: Path where SAS file should be written
            input_dataset: Input dataset name (e.g., "work.dm"), optional
            output_dataset: Output dataset name (e.g., "sdtm.dm"), optional

        Raises:
            Exception: If generation or writing fails

        Example:
            >>> writer = SASWriter()
            >>> writer.write("DM", config, Path("dm.sas"), "raw.demo", "final.dm")
        """
        effective_input_dataset = input_dataset or f"work.{domain_code.lower()}"
        effective_output_dataset = output_dataset or f"sdtm.{domain_code.lower()}"

        try:
            sas_code = generate_sas_program(
                domain_code,
                config,
                input_dataset=effective_input_dataset,
                output_dataset=effective_output_dataset,
            )
            write_sas_file(sas_code, output_path)
        except (OSError, TypeError, ValueError, KeyError) as exc:
            raise SASWriterError(
                f"Failed to generate/write SAS program: {exc}"
            ) from exc
