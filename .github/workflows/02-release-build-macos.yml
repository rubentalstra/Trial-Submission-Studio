# yaml-language-server: $schema=https://json.schemastore.org/github-workflow.json
name: Build macOS

on:
  workflow_call:
    inputs:
      version:
        description: "Release version (e.g., v0.1.0)"
        required: true
        type: string
      build_number:
        description: "Build number (e.g., TSS-123.456)"
        required: true
        type: string
    secrets:
      APPLE_DEVELOPER_CERTIFICATE_P12_BASE64:
        required: true
      APPLE_DEVELOPER_CERTIFICATE_PASSWORD:
        required: true
      APPLE_CODESIGN_IDENTITY:
        required: true
      APPLE_NOTARIZATION_APPLE_ID:
        required: true
      APPLE_NOTARIZATION_APP_PASSWORD:
        required: true
      APPLE_DEVELOPER_TEAM_ID:
        required: true
      CI_KEYCHAIN_PASSWORD:
        required: true

permissions:
  contents: read

env:
  CARGO_TERM_COLOR: always
  CARGO_INCREMENTAL: 0
  APP_NAME: trial-submission-studio
  BUNDLE_NAME: "Trial Submission Studio"

jobs:
  build:
    name: Build ${{ matrix.target }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - target: aarch64-apple-darwin
            runner: macos-latest
            artifact-name: macos-arm64
          - target: x86_64-apple-darwin
            runner: macos-13
            artifact-name: macos-x86_64
    runs-on: ${{ matrix.runner }}
    timeout-minutes: 60
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: release-${{ matrix.target }}
          cache-on-failure: true

      - name: Cache Homebrew packages
        uses: actions/cache@v4
        with:
          path: |
            ~/Library/Caches/Homebrew
            /usr/local/Cellar/create-dmg
            /opt/homebrew/Cellar/create-dmg
          key: brew-create-dmg-${{ runner.os }}-${{ runner.arch }}-v1

      - name: Build release binary
        env:
          TSS_BUILD_NUMBER: ${{ inputs.build_number }}
        run: |
          echo "Building for target: ${{ matrix.target }}"
          cargo build --release --target ${{ matrix.target }}

      - name: Create App Bundle
        env:
          VERSION: ${{ inputs.version }}
          BUILD_VERSION: ${{ inputs.build_number }}
        run: |
          set -euo pipefail

          APP_DIR="${BUNDLE_NAME}.app"
          mkdir -p "$APP_DIR/Contents/MacOS"
          mkdir -p "$APP_DIR/Contents/Resources"

          # Copy binary
          cp "target/${{ matrix.target }}/release/${APP_NAME}" "$APP_DIR/Contents/MacOS/"

          # Extract marketing version (strip v prefix and pre-release suffixes)
          MARKETING_VERSION=$(echo "${VERSION}" | sed -E 's/^v//' | sed -E 's/-(alpha|beta|rc)\.[0-9]+$//')

          echo "Marketing Version: $MARKETING_VERSION"
          echo "Build Version: $BUILD_VERSION"

          # Process Info.plist template
          sed -e "s/\${BUILD_VERSION}/${BUILD_VERSION}/g" \
              -e "s/\${MARKETING_VERSION}/${MARKETING_VERSION}/g" \
              packaging/macos/Info.plist > "$APP_DIR/Contents/Info.plist"

          # Copy static files
          cp packaging/macos/AppIcon.icns "$APP_DIR/Contents/Resources/"
          cp packaging/macos/PkgInfo "$APP_DIR/Contents/"

          echo "App bundle created: $APP_DIR"

      - name: Validate App Bundle
        run: |
          set -euo pipefail
          APP_DIR="${BUNDLE_NAME}.app"

          echo "=== Validating Info.plist ==="
          plutil -lint "$APP_DIR/Contents/Info.plist"

          # Verify required keys
          plutil -extract CFBundleIdentifier raw "$APP_DIR/Contents/Info.plist"
          plutil -extract CFBundleVersion raw "$APP_DIR/Contents/Info.plist"
          plutil -extract CFBundleShortVersionString raw "$APP_DIR/Contents/Info.plist"
          plutil -extract LSMinimumSystemVersion raw "$APP_DIR/Contents/Info.plist"

          # Verify JetBrains-style build version format: TSS-{number}.{number}
          BUNDLE_VERSION=$(plutil -extract CFBundleVersion raw "$APP_DIR/Contents/Info.plist")
          if ! [[ "$BUNDLE_VERSION" =~ ^TSS-[0-9]+\.[0-9]+$ ]]; then
            echo "::error::CFBundleVersion must be TSS-X.Y format, got: $BUNDLE_VERSION"
            exit 1
          fi

          # Verify marketing version is n.n.n format
          SHORT_VERSION=$(plutil -extract CFBundleShortVersionString raw "$APP_DIR/Contents/Info.plist")
          if ! [[ "$SHORT_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "::error::CFBundleShortVersionString must be n.n.n format, got: $SHORT_VERSION"
            exit 1
          fi

          echo "  CFBundleVersion: $BUNDLE_VERSION"
          echo "  CFBundleShortVersionString: $SHORT_VERSION"

          echo "=== Validating PkgInfo ==="
          PKGINFO=$(cat "$APP_DIR/Contents/PkgInfo")
          if [[ "$PKGINFO" != "APPL????" ]]; then
            echo "::error::PkgInfo invalid, expected 'APPL????' got '$PKGINFO'"
            exit 1
          fi

          echo "=== Validating bundle structure ==="
          test -f "$APP_DIR/Contents/MacOS/${APP_NAME}" || { echo "::error::Binary missing"; exit 1; }
          test -f "$APP_DIR/Contents/Info.plist" || { echo "::error::Info.plist missing"; exit 1; }
          test -f "$APP_DIR/Contents/Resources/AppIcon.icns" || { echo "::error::Icon missing"; exit 1; }
          test -f "$APP_DIR/Contents/PkgInfo" || { echo "::error::PkgInfo missing"; exit 1; }

          echo "Bundle validation passed"

      - name: Import Code Signing Certificate
        env:
          APPLE_DEVELOPER_CERTIFICATE_P12_BASE64: ${{ secrets.APPLE_DEVELOPER_CERTIFICATE_P12_BASE64 }}
          APPLE_DEVELOPER_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_DEVELOPER_CERTIFICATE_PASSWORD }}
          CI_KEYCHAIN_PASSWORD: ${{ secrets.CI_KEYCHAIN_PASSWORD }}
        run: |
          set -euo pipefail

          # Create a new keychain for CI
          security create-keychain -p "$CI_KEYCHAIN_PASSWORD" build.keychain

          # Add keychain to search list (required for codesign to find certificate)
          security list-keychains -d user -s build.keychain login.keychain

          # Set as default and unlock
          security default-keychain -s build.keychain
          security unlock-keychain -p "$CI_KEYCHAIN_PASSWORD" build.keychain

          # Set keychain timeout to 1 hour
          security set-keychain-settings -t 3600 -u build.keychain

          # Import certificate
          echo "$APPLE_DEVELOPER_CERTIFICATE_P12_BASE64" | base64 --decode > certificate.p12
          security import certificate.p12 -k build.keychain \
            -P "$APPLE_DEVELOPER_CERTIFICATE_PASSWORD" \
            -T /usr/bin/codesign -T /usr/bin/security
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$CI_KEYCHAIN_PASSWORD" build.keychain
          rm certificate.p12

          # Verify certificate was imported
          echo "Verifying certificate import..."
          security find-identity -v -p codesigning build.keychain

          echo "Certificate imported successfully"

      - name: Sign App Bundle
        env:
          APPLE_CODESIGN_IDENTITY: ${{ secrets.APPLE_CODESIGN_IDENTITY }}
        run: |
          codesign --force --options runtime \
            --entitlements packaging/macos/entitlements.plist \
            --sign "$APPLE_CODESIGN_IDENTITY" \
            --timestamp \
            "${BUNDLE_NAME}.app"

          echo "App bundle signed"

      - name: Verify Code Signature
        run: |
          set -euo pipefail

          echo "=== Verifying signature ==="
          codesign --verify --deep --strict --verbose=2 "${BUNDLE_NAME}.app"

          echo "=== Checking hardened runtime ==="
          codesign -d --verbose=4 "${BUNDLE_NAME}.app" 2>&1 | grep -q "runtime" || {
            echo "::error::Hardened runtime not enabled"
            exit 1
          }

          echo "Signature verification passed"

      - name: Notarize App
        timeout-minutes: 30
        env:
          APPLE_NOTARIZATION_APPLE_ID: ${{ secrets.APPLE_NOTARIZATION_APPLE_ID }}
          APPLE_NOTARIZATION_APP_PASSWORD: ${{ secrets.APPLE_NOTARIZATION_APP_PASSWORD }}
          APPLE_DEVELOPER_TEAM_ID: ${{ secrets.APPLE_DEVELOPER_TEAM_ID }}
        run: |
          set -euo pipefail

          echo "Creating ZIP for notarization..."
          ditto -c -k --keepParent "${BUNDLE_NAME}.app" notarize.zip

          echo "Submitting for notarization..."
          xcrun notarytool submit notarize.zip \
            --apple-id "$APPLE_NOTARIZATION_APPLE_ID" \
            --password "$APPLE_NOTARIZATION_APP_PASSWORD" \
            --team-id "$APPLE_DEVELOPER_TEAM_ID" \
            --wait --timeout 30m

          echo "Stapling notarization ticket..."
          xcrun stapler staple "${BUNDLE_NAME}.app"

          rm notarize.zip
          echo "Notarization complete"

      - name: Verify Notarization
        run: |
          set -euo pipefail

          echo "=== Validating stapled ticket ==="
          xcrun stapler validate "${BUNDLE_NAME}.app" || {
            echo "::error::Stapling validation failed"
            exit 1
          }

          echo "=== Gatekeeper assessment ==="
          spctl --assess --type execute --verbose=2 "${BUNDLE_NAME}.app" || {
            echo "::error::Gatekeeper rejected app"
            exit 1
          }

          echo "Notarization verification passed"

      - name: Create DMG
        env:
          VERSION: ${{ inputs.version }}
        run: |
          set -euo pipefail

          brew install create-dmg || true

          DMG_NAME="${APP_NAME}-${VERSION}-${{ matrix.target }}.dmg"

          create-dmg \
            --volname "${BUNDLE_NAME}" \
            --volicon "packaging/macos/AppIcon.icns" \
            --window-pos 200 120 \
            --window-size 600 400 \
            --icon-size 100 \
            --icon "${BUNDLE_NAME}.app" 150 190 \
            --hide-extension "${BUNDLE_NAME}.app" \
            --app-drop-link 450 190 \
            "$DMG_NAME" \
            "${BUNDLE_NAME}.app" || true

          # Verify DMG was created (create-dmg returns 2 on success sometimes)
          test -f "$DMG_NAME" || {
            echo "::error::DMG not created"
            exit 1
          }

          echo "DMG created: $DMG_NAME"

      - name: Sign and Notarize DMG
        timeout-minutes: 30
        env:
          VERSION: ${{ inputs.version }}
          APPLE_CODESIGN_IDENTITY: ${{ secrets.APPLE_CODESIGN_IDENTITY }}
          APPLE_NOTARIZATION_APPLE_ID: ${{ secrets.APPLE_NOTARIZATION_APPLE_ID }}
          APPLE_NOTARIZATION_APP_PASSWORD: ${{ secrets.APPLE_NOTARIZATION_APP_PASSWORD }}
          APPLE_DEVELOPER_TEAM_ID: ${{ secrets.APPLE_DEVELOPER_TEAM_ID }}
        run: |
          set -euo pipefail

          DMG_NAME="${APP_NAME}-${VERSION}-${{ matrix.target }}.dmg"

          echo "Signing DMG..."
          codesign --force --sign "$APPLE_CODESIGN_IDENTITY" --timestamp "$DMG_NAME"

          echo "Notarizing DMG..."
          xcrun notarytool submit "$DMG_NAME" \
            --apple-id "$APPLE_NOTARIZATION_APPLE_ID" \
            --password "$APPLE_NOTARIZATION_APP_PASSWORD" \
            --team-id "$APPLE_DEVELOPER_TEAM_ID" \
            --wait --timeout 30m

          echo "Stapling DMG..."
          xcrun stapler staple "$DMG_NAME"

          echo "DMG signed and notarized"

      - name: Create ZIP archive
        env:
          VERSION: ${{ inputs.version }}
        run: |
          ZIP_NAME="${APP_NAME}-${VERSION}-${{ matrix.target }}.zip"
          ditto -c -k --keepParent "${BUNDLE_NAME}.app" "$ZIP_NAME"
          echo "ZIP created: $ZIP_NAME"

      - name: Create tar.gz archive
        env:
          VERSION: ${{ inputs.version }}
        run: |
          TAR_NAME="${APP_NAME}-${VERSION}-${{ matrix.target }}.tar.gz"

          # Create a directory with the app bundle for tarball
          mkdir -p release-tar
          cp -R "${BUNDLE_NAME}.app" release-tar/

          tar -czvf "$TAR_NAME" -C release-tar .
          rm -rf release-tar

          echo "Tarball created: $TAR_NAME"

      - name: Upload artifacts
        uses: actions/upload-artifact@v6
        with:
          name: ${{ matrix.artifact-name }}
          path: |
            ${{ env.APP_NAME }}-${{ inputs.version }}-${{ matrix.target }}.dmg
            ${{ env.APP_NAME }}-${{ inputs.version }}-${{ matrix.target }}.zip
            ${{ env.APP_NAME }}-${{ inputs.version }}-${{ matrix.target }}.tar.gz
          if-no-files-found: error
          retention-days: 7

      - name: Cleanup keychain
        if: always()
        run: |
          security delete-keychain build.keychain 2>/dev/null || true
