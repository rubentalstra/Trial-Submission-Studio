name: Build macOS

on:
  workflow_call:
    inputs:
      version:
        required: true
        type: string
      build_number:
        required: true
        type: string
    secrets:
      APPLE_DEVELOPER_CERTIFICATE_P12_BASE64:
        required: true
      APPLE_DEVELOPER_CERTIFICATE_PASSWORD:
        required: true
      APPLE_CODESIGN_IDENTITY:
        required: true
      APPLE_NOTARIZATION_APPLE_ID:
        required: true
      APPLE_NOTARIZATION_APP_PASSWORD:
        required: true
      APPLE_DEVELOPER_TEAM_ID:
        required: true
      CI_KEYCHAIN_PASSWORD:
        required: true

permissions:
  contents: read

jobs:
  build:
    name: Build ${{ matrix.artifact-name }}
    env:
      CARGO_TERM_COLOR: always
      APP_NAME: trial-submission-studio
      BUNDLE_NAME: "Trial Submission Studio"
    strategy:
      fail-fast: false
      matrix:
        include:
          - target: aarch64-apple-darwin
            runner: macos-latest
            artifact-name: macos-arm64
          - target: x86_64-apple-darwin
            runner: macos-15-intel
            artifact-name: macos-x86_64
    runs-on: ${{ matrix.runner }}
    timeout-minutes: 45
    steps:
      - uses: actions/checkout@v6

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - uses: Swatinem/rust-cache@v2
        with:
          shared-key: "release-${{ matrix.artifact-name }}"
          cache-on-failure: true

      - name: Cache Homebrew packages
        uses: actions/cache@v4
        with:
          path: |
            ~/Library/Caches/Homebrew
            /usr/local/Cellar/create-dmg
            /opt/homebrew/Cellar/create-dmg
          key: brew-create-dmg-${{ runner.os }}-${{ runner.arch }}

      - name: Build
        run: cargo build --release --target ${{ matrix.target }}

      - name: Create App Bundle
        env:
          VERSION: ${{ inputs.version }}
          RUN_NUMBER: ${{ inputs.build_number }}
          RUN_ID: ${{ github.run_id }}
        run: |
          APP_DIR="${BUNDLE_NAME}.app"
          mkdir -p "$APP_DIR/Contents/MacOS"
          mkdir -p "$APP_DIR/Contents/Resources"

          # Copy binary
          cp "target/${{ matrix.target }}/release/${APP_NAME}" "$APP_DIR/Contents/MacOS/"

          # Extract marketing version (strip -alpha.X, -beta.X, -rc.X suffixes)
          MARKETING_VERSION=$(echo "${VERSION}" | sed -E 's/-(alpha|beta|rc)\.[0-9]+$//')

          # Generate JetBrains-style build version: TSS-{run_number}.{git_commit_count}
          COMMIT_COUNT=$(git rev-list --count HEAD)
          BUILD_VERSION="TSS-${RUN_NUMBER}.${COMMIT_COUNT}"

          # Gather git metadata
          GIT_COMMIT_SHA=$(git rev-parse HEAD)
          GIT_COMMIT_SHORT=$(git rev-parse --short HEAD)
          GIT_BRANCH="${GITHUB_REF_NAME:-$(git branch --show-current)}"
          GIT_CLEAN=$(git diff --quiet && echo "true" || echo "false")

          # Gather build environment metadata
          BUILD_DATE=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          BUILD_TIMESTAMP=$(date +%s)
          RUST_VERSION=$(rustc --version | cut -d' ' -f2)

          echo "Marketing Version: $MARKETING_VERSION"
          echo "Build Version: $BUILD_VERSION"
          echo "Git SHA: $GIT_COMMIT_SHORT"

          # Process Info.plist template
          sed -e "s/\${BUILD_VERSION}/${BUILD_VERSION}/g" \
              -e "s/\${MARKETING_VERSION}/${MARKETING_VERSION}/g" \
              packaging/macos/Info.plist > "$APP_DIR/Contents/Info.plist"

          # Process version.plist template (enterprise build metadata)
          # Note: Using | as delimiter for GIT_BRANCH since branch names can contain /
          sed -e "s/\${MARKETING_VERSION}/${MARKETING_VERSION}/g" \
              -e "s/\${FULL_VERSION}/${VERSION}/g" \
              -e "s/\${BUILD_VERSION}/${BUILD_VERSION}/g" \
              -e "s/\${GIT_COMMIT_SHA}/${GIT_COMMIT_SHA}/g" \
              -e "s/\${GIT_COMMIT_SHORT}/${GIT_COMMIT_SHORT}/g" \
              -e "s|\${GIT_BRANCH}|${GIT_BRANCH}|g" \
              -e "s/\${GIT_COMMIT_COUNT}/${COMMIT_COUNT}/g" \
              -e "s/\${GIT_CLEAN}/${GIT_CLEAN}/g" \
              -e "s/\${BUILD_DATE}/${BUILD_DATE}/g" \
              -e "s/\${BUILD_TIMESTAMP}/${BUILD_TIMESTAMP}/g" \
              -e "s|\${TARGET_ARCH}|${{ matrix.target }}|g" \
              -e "s/\${RUST_VERSION}/${RUST_VERSION}/g" \
              -e "s/\${BUILD_TYPE}/release/g" \
              -e "s/\${CI_PROVIDER}/github-actions/g" \
              -e "s/\${CI_RUN_NUMBER}/${RUN_NUMBER}/g" \
              -e "s/\${CI_RUN_ID}/${RUN_ID}/g" \
              packaging/macos/version.plist > "$APP_DIR/Contents/Resources/version.plist"

          # Copy static files
          cp packaging/macos/AppIcon.icns "$APP_DIR/Contents/Resources/"
          cp packaging/macos/PkgInfo "$APP_DIR/Contents/"

      - name: Validate App Bundle
        run: |
          APP_DIR="${BUNDLE_NAME}.app"

          # Validate plist syntax
          echo "Validating Info.plist..."
          plutil -lint "$APP_DIR/Contents/Info.plist"

          # Verify required keys exist
          plutil -extract CFBundleIdentifier raw "$APP_DIR/Contents/Info.plist"
          plutil -extract CFBundleVersion raw "$APP_DIR/Contents/Info.plist"
          plutil -extract CFBundleShortVersionString raw "$APP_DIR/Contents/Info.plist"
          plutil -extract LSMinimumSystemVersion raw "$APP_DIR/Contents/Info.plist"

          # Verify JetBrains-style build version format: TSS-{number}.{number}
          BUNDLE_VERSION=$(plutil -extract CFBundleVersion raw "$APP_DIR/Contents/Info.plist")
          if ! [[ "$BUNDLE_VERSION" =~ ^TSS-[0-9]+\.[0-9]+$ ]]; then
            echo "ERROR: CFBundleVersion must be TSS-X.Y format, got: $BUNDLE_VERSION"
            exit 1
          fi

          # Verify marketing version is n.n.n format
          SHORT_VERSION=$(plutil -extract CFBundleShortVersionString raw "$APP_DIR/Contents/Info.plist")
          if ! [[ "$SHORT_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "ERROR: CFBundleShortVersionString must be n.n.n format, got: $SHORT_VERSION"
            exit 1
          fi

          echo "Info.plist validation passed"
          echo "  CFBundleVersion: $BUNDLE_VERSION"
          echo "  CFBundleShortVersionString: $SHORT_VERSION"

          # Validate version.plist
          echo "Validating version.plist..."
          plutil -lint "$APP_DIR/Contents/Resources/version.plist"

          # Verify version.plist contains expected metadata
          GIT_SHA=$(plutil -extract GitCommitSHA raw "$APP_DIR/Contents/Resources/version.plist")
          if [[ -z "$GIT_SHA" || "$GIT_SHA" == *'${'* ]]; then
            echo "ERROR: version.plist GitCommitSHA not properly substituted"
            exit 1
          fi

          echo "version.plist validation passed"
          echo "  GitCommitSHA: $GIT_SHA"

          # Validate PkgInfo
          echo "Validating PkgInfo..."
          PKGINFO=$(cat "$APP_DIR/Contents/PkgInfo")
          if [[ "$PKGINFO" != "APPL????" ]]; then
            echo "ERROR: PkgInfo invalid, expected 'APPL????' got '$PKGINFO'"
            exit 1
          fi
          echo "PkgInfo validation passed"

          # Validate bundle structure
          echo "Validating bundle structure..."
          test -f "$APP_DIR/Contents/MacOS/${APP_NAME}" || { echo "ERROR: Binary missing"; exit 1; }
          test -f "$APP_DIR/Contents/Info.plist" || { echo "ERROR: Info.plist missing"; exit 1; }
          test -f "$APP_DIR/Contents/Resources/AppIcon.icns" || { echo "ERROR: Icon missing"; exit 1; }
          test -f "$APP_DIR/Contents/Resources/version.plist" || { echo "ERROR: version.plist missing"; exit 1; }
          test -f "$APP_DIR/Contents/PkgInfo" || { echo "ERROR: PkgInfo missing"; exit 1; }

          echo "Bundle structure validated"

      - name: Import Certificate
        env:
          APPLE_DEVELOPER_CERTIFICATE_P12_BASE64: ${{ secrets.APPLE_DEVELOPER_CERTIFICATE_P12_BASE64 }}
          APPLE_DEVELOPER_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_DEVELOPER_CERTIFICATE_PASSWORD }}
          CI_KEYCHAIN_PASSWORD: ${{ secrets.CI_KEYCHAIN_PASSWORD }}
        run: |
          # Create a new keychain for CI
          security create-keychain -p "$CI_KEYCHAIN_PASSWORD" build.keychain

          # Add keychain to search list (CRITICAL: required for codesign to find certificate)
          security list-keychains -d user -s build.keychain login.keychain

          # Set as default and unlock
          security default-keychain -s build.keychain
          security unlock-keychain -p "$CI_KEYCHAIN_PASSWORD" build.keychain

          # Set keychain timeout to 1 hour
          security set-keychain-settings -t 3600 -u build.keychain

          # Import certificate
          echo "$APPLE_DEVELOPER_CERTIFICATE_P12_BASE64" | base64 --decode > certificate.p12
          security import certificate.p12 -k build.keychain \
            -P "$APPLE_DEVELOPER_CERTIFICATE_PASSWORD" \
            -T /usr/bin/codesign -T /usr/bin/security
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$CI_KEYCHAIN_PASSWORD" build.keychain
          rm certificate.p12

          # Verify certificate was imported
          security find-identity -v -p codesigning build.keychain
          echo "Certificate imported"

      - name: Sign App Bundle
        env:
          APPLE_CODESIGN_IDENTITY: ${{ secrets.APPLE_CODESIGN_IDENTITY }}
        run: |
          codesign --force --options runtime \
            --entitlements packaging/macos/entitlements.plist \
            --sign "$APPLE_CODESIGN_IDENTITY" \
            --timestamp \
            "${BUNDLE_NAME}.app"
          echo "App signed"

      - name: Verify Signature
        run: |
          codesign --verify --deep --strict --verbose=2 "${BUNDLE_NAME}.app"
          codesign -d --verbose=4 "${BUNDLE_NAME}.app" 2>&1 | grep -q "runtime" || { echo "ERROR: Hardened runtime not enabled"; exit 1; }
          echo "Signature verified"

      - name: Notarize App
        timeout-minutes: 30
        env:
          APPLE_NOTARIZATION_APPLE_ID: ${{ secrets.APPLE_NOTARIZATION_APPLE_ID }}
          APPLE_NOTARIZATION_APP_PASSWORD: ${{ secrets.APPLE_NOTARIZATION_APP_PASSWORD }}
          APPLE_DEVELOPER_TEAM_ID: ${{ secrets.APPLE_DEVELOPER_TEAM_ID }}
        run: |
          ditto -c -k --keepParent "${BUNDLE_NAME}.app" notarize.zip
          xcrun notarytool submit notarize.zip \
            --apple-id "$APPLE_NOTARIZATION_APPLE_ID" \
            --password "$APPLE_NOTARIZATION_APP_PASSWORD" \
            --team-id "$APPLE_DEVELOPER_TEAM_ID" \
            --wait --timeout 30m
          xcrun stapler staple "${BUNDLE_NAME}.app"
          rm notarize.zip
          echo "App notarized and stapled"

      - name: Verify Notarization
        run: |
          xcrun stapler validate "${BUNDLE_NAME}.app" || { echo "ERROR: Stapling failed"; exit 1; }
          spctl --assess --type execute --verbose=2 "${BUNDLE_NAME}.app" || { echo "ERROR: Gatekeeper rejected app"; exit 1; }
          echo "Notarization verified"

      - name: Create DMG
        env:
          VERSION: ${{ inputs.version }}
        run: |
          brew install create-dmg
          create-dmg \
            --volname "${BUNDLE_NAME}" \
            --volicon "packaging/macos/AppIcon.icns" \
            --window-pos 200 120 --window-size 600 400 \
            --icon-size 100 --icon "${BUNDLE_NAME}.app" 150 190 \
            --hide-extension "${BUNDLE_NAME}.app" \
            --app-drop-link 450 190 \
            "${APP_NAME}-${VERSION}-${{ matrix.target }}.dmg" \
            "${BUNDLE_NAME}.app" || true
          # Verify DMG was created (create-dmg returns 2 on success sometimes)
          test -f "${APP_NAME}-${VERSION}-${{ matrix.target }}.dmg" || { echo "ERROR: DMG not created"; exit 1; }
          echo "DMG created"

      - name: Sign and Notarize DMG
        timeout-minutes: 30
        env:
          VERSION: ${{ inputs.version }}
          APPLE_CODESIGN_IDENTITY: ${{ secrets.APPLE_CODESIGN_IDENTITY }}
          APPLE_NOTARIZATION_APPLE_ID: ${{ secrets.APPLE_NOTARIZATION_APPLE_ID }}
          APPLE_NOTARIZATION_APP_PASSWORD: ${{ secrets.APPLE_NOTARIZATION_APP_PASSWORD }}
          APPLE_DEVELOPER_TEAM_ID: ${{ secrets.APPLE_DEVELOPER_TEAM_ID }}
        run: |
          DMG="${APP_NAME}-${VERSION}-${{ matrix.target }}.dmg"
          codesign --force --sign "$APPLE_CODESIGN_IDENTITY" --timestamp "$DMG"
          xcrun notarytool submit "$DMG" \
            --apple-id "$APPLE_NOTARIZATION_APPLE_ID" \
            --password "$APPLE_NOTARIZATION_APP_PASSWORD" \
            --team-id "$APPLE_DEVELOPER_TEAM_ID" \
            --wait --timeout 30m
          xcrun stapler staple "$DMG"
          echo "DMG signed and notarized"

      - name: Create ZIP
        env:
          VERSION: ${{ inputs.version }}
        run: |
          ditto -c -k --keepParent "${BUNDLE_NAME}.app" "${APP_NAME}-${VERSION}-${{ matrix.target }}.zip"

      - name: Upload Artifacts
        uses: actions/upload-artifact@v6
        with:
          name: ${{ matrix.artifact-name }}
          path: |
            ${{ env.APP_NAME }}-*.dmg
            ${{ env.APP_NAME }}-*.zip
          if-no-files-found: error
